# 笔试题详解

## 数据结构

- 5

> step1：A，B，C 入栈
> step2:C 出栈
> step3：D,E,F 入栈
> step4:F,E,D,B,A 出栈
> 栈内最多有 5 个元素同时存在

- 45231

-

## 编程基础

- \*2

> 十进制数据右移 n 位，乘以 10^n,左移 n 位，除以 10^n
> 二进制数据右移 n 位，乘以 2^n,左移 n 位，除以 2^n(右移数据变大，乘操作，左移数据变小，除操作)

## 操作系统

- 地址空间, 全局变量, 打开的文件, 子进程, 信号量, 账户信息

> 进程占有的资源:
> 地址空间, 全局变量, 打开的文件, 子进程, 信号量, 账户信息
> 线程占有的资源:
> 栈, 寄存器, 状态, 程序计数器
> 线程占有的都是不共享的
> 堆: 是大家共有的空间, 分全局堆和局部堆, 全局堆就是所有没有分配的空间, 局部堆就是用户分配的空间, 堆在操作系统对进程初始化的时候分配, 运行过程中也可以向系统要额外的堆, 但是记得用完了要还给操作系统, 要不然就是内存泄漏
> 栈：是个线程独有的, 保存其运行状态和局部自动变量的, 栈在线程开始的时候初始化, 每个线程的栈互相独立, 因此, 栈是 thread safe 的, 操作系统在切换线程的时候会自动的切换栈, 就是切换 SS/ESP 寄存器, 栈空间不需要在高级语言里面显式的分配和释放

## 网络基础

- 1001

> 确认序列号=原始序列号+TCP 段的长度, 所以第一次的确认序列号为 200+300=500, 第二次确认序列号为 500+500=1000 + 1, TCP 的报文到达确认(ACK), 是对接收到的数据的最高序列号的确认, 并向发送端返回一个下次接收时期望的 TCP 数据包的序列号(Ack Number), 例如, 主机 A 发送的当前数据序号是 400, 数据长度是 100, 则接收端收到后会返回一个确认号是 501 的确认号给主机 A

- ARP DNS HTTP

> tcp/ip 分层的问题, tcp/ip 协议的网络分为 5 层, 分别是应用层, 传输层, 网络层, 数据链路层, 物理层然后就是各层中有哪些协议, 信息发送出去都是由低层逐层向上传递的, arp 是数据链路层的协议, dns 是网络层的协议, http 是应用层的协议
> 当给 WEB 服务器接上网线的时候, 它会自动发送一条 ARP 信息, 使得接入网关能找的到它, 网关上会形成一条类似 2c 96 1e 3c 3e 9b - 192.168.1.123 的 MAC 地址到 IP 地址的映射记录
> 当第一个用户使用域名访问 WEB 服务器的时候, 首先要进行一次 DNS 查询
> 最后才是 http 协议

- 302

> 304 未修改(表示客户机缓存的版本是最新的, 客户机应该继续使用它)
> 404 找不到改页面
> 302 暂时重定向
> 400 代表客户端发起的请求不符合服务器对请求的某些限制, 或者请求本身存在一定的错误

- 跨域

- 多路 I/O 机制的解决方案

> select 和 epoll 这两个机制都是多路 I/O 机制的解决方案, select 为 POSIX 标准中的, 而 epoll 为 Linux 所特有的
> epoll 的最大好处是不会随着 FD 的数目增长而降低效率, 在 select 中采用轮询处理, 其中的数据结构类似一个数组的数据结构, 而 epoll 是维护一个队列, 直接看队列是不是空就可以了
> nginx 就是使用 epoll 来实现 I/O 复用支持高并发, 目前在高并发的场景下, nginx 越来越收到欢迎
> select 的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制
> epoll:
> (1)IO 的效率不会随着监视 fd 的数量的增长而下降, epoll 不同于 select 和 poll 轮询的方式, 而是通过每个 fd 定义的回调函数来实现的, 只有就绪的 fd 才会执行回调函数
> (2)支持电平触发和边沿触发(只告诉进程哪些文件描述符刚刚变为就绪状态, 它只说一遍, 如果我们没有采取行动, 那么它将不会再次告知, 这种方式称为边缘触发)两种方式, 理论上边缘触发的性能要更高一些, 但是代码实现相当复杂
> (3)有着良好的就绪事件通知机制
> select:
> (1)单个进程可监视的 fd 数量受到了限制, 在 32 位机器上, 他所能管理的 fd 数量最大为 1024
> (2)对 socket 进行扫描时是线性扫描, 当 socket 文件描述符数量变多时, 大量的时间是被白白浪费掉的

## 算法

- 归并, 插入排序

> 不稳定的排序算法: 选择排序(5,7,5,3)3 和 5 交换之后, 两个 5 的相对顺序发生了变化)

                 shell排序(1,5,5,2,3,7)间隔序列为(3,1), 3的时候(1,5,7)(5,2,3)), 在间隔>1的时候会出现不稳定
                 快速排序(3,5,5,4,2,1)
                 堆排序, 构造堆的时候时稳定的, 但是在根节点与尾节点交换之后, 根节点成为了序列中最后一个, 如果字节点之一与根节点相同, 则其不稳定

- 归并排序

> 冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为 O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)
> 快速排序空间复杂度为 logn(因为递归调用了)
> 归并排序空间复杂是 O(n),需要一个大小为 n 的临时数组
> 基数排序的空间复杂是 O(n),桶排序的空间复杂度不确定

## 数据库

- B, C

> A 返回的是表的行数, 如果没有记录, 应该返回 0, 不会出现 NULL
> B,C 正常情况下不会出现 NULL, 但是如果表里面没有记录, 则会出现 NULL
> CONCAT(str1,str2,…)返回结果为连接参数产生的字符串, 如有任何一个参数为 NULL, 则返回值为 NULL

- SELECT \* FROM tbl_user WHERE 1=1 GROUP BY username HAVING count(1) > 1 ORDER BY created_date DESC limit 1, 5

## linux

- su

> su 和 su -是有区别的, su -会切换环境变量, su 只是切换用户

## java

- 1

- 语句: b3=b1+b2 编译出错

> 被 final 修饰的变量是常量, 这里的 b6=b4+b5 可以看成是 b6=10, 在编译时就已经变为 b6=10 了
> 而 b1 和 b2 是 byte 类型, java 中进行计算时候将他们提升为 int 类型, 再进行计算, b1+b2 计算后已经是 int 类型, 赋值给 b3, b3 是 byte 类型, 类型不匹配, 编译不会通过, 需要进行强制转换
> Java 中的 byte, short, char 进行计算时都会提升为 int 类型

- finally, result

> 先执行 return 缓存起来, 再执行 finally 模块, 然后再执行 return

- true, true

> 基本型和基本型封装型进行"=="运算符的比较, 基本型封装型将会自动拆箱变为基本型后再进行比较, 因此 Integer(0)会自动拆箱为 int 类型再进行比较
> 两个 Integer 类型进行"=="比较, 如果其值在-128 至 127, 那么返回 true, 否则返回 false, 这跟 Integer.valueOf()的缓冲对象有关
> 两个基本型的封装型进行 equals()比较, 首先 equals()会比较类型, 如果类型相同, 则继续比较值, 如果值也相同, 返回 true
> 基本型封装类型调用 equals(), 但是参数是基本类型, 这时候, 先会进行自动装箱, 基本型转换为其封装类型, 再进行 3 中的比较

- sleep, wait

> 对于 sleep()方法属于 Thread 类中的, 而 wait()方法则是属于 Object 类中的, sleep()方法导致了程序暂停执行指定的时间, 让出 cpu 该其他线程, 但是他的监控状态依然保持者, 当指定的时间到了又会自动恢复运行状态
> 在调用 sleep()方法的过程中, 线程不会释放对象锁
> 而当调用 wait()方法的时候, 线程会放弃对象锁, 进入等待此对象的等待锁定池, 只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备
> sleep()是当前正在运行的线程主动放弃 CPU, 进入睡眠状态
> sleep 阻塞但不释放这个对象的锁
> sleep 方法是在指定的时间内让正在执行的线程暂停执行, 但不会释放锁, 而 wait 方法是让当前线程等待, 直到其他线程调用对象的 notify 或 notifyAll 方法, wait 方法会释放掉锁, 使别的线程有机会占用锁

- 自旋锁, 自旋锁的其他种类, 阻塞锁, 可重入锁, 读写锁, 互斥锁, 悲观锁, 乐观锁, 公平锁, 非公平锁, 偏向锁, 对象锁, 线程锁, 锁粗化, 轻量级锁, 锁消除, 锁膨胀, 信号量

## 智力题

- B

> 有唯一的错误, 那么 6 个中肯定有 5 个时对的, 所以 A 正确
> 如果 C 错误, 那么 D 错误, 有两个错误, 不符
> 如果 D 错误, 那么 E 正确, E 说 ABC 中有一个错误, 而 D 错误, 冲突, 所以不是 D
> 如果 E 错误, 而 D 说 DEF 都正确, 有两个错误, 冲突, 不是 E
> 如果 F 错误, 和自己冲突
> 综上, B 错误, 而且没有冲突

- 3

> 第 1 次：120 平分, 得到 60
> 第 2 次：60 平分, 得到 30
> 第 3 次：30 平分, 得到 15, 和剩下的 10 加在一块就是 25
