# 引言

在一些物理内存为 8g 的服务器上，主要运行一个 Java 服务，系统内存分配如下：Java 服务的 JVM 堆大小设置为 6g，一个监控进程占用大约 600m，Linux 自身使用大约 800m。从表面上，物理内存应该是足够使用的；但实际运行的情况是，会发生大量使用 SWAP(说明物理内存不够使用 了)，如下图所示。同时，由于 SWAP 和 GC 同时发生会致使 JVM 严重卡顿，所以我们要追问：内存究竟去哪儿了？

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223218_876.jpg '01')](http://www.importnew.com/14486.html/01-3)

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223218_984.jpg '02')](http://www.importnew.com/14486.html/02-3)

要分析这个问题，理解 JVM 和操作系统之间的内存关系非常重要。接下来主要就 Linux 与 JVM 之间的内存关系进行一些分析。

# 一、Linux 与进程内存模型

JVM 以一个进程（Process）的身份运行在 Linux 系统上，了解 Linux 与进程的内存关系，是理解 JVM 与 Linux 内存的关系的基础。  
下图给出了硬件、系统、进程三个层面的内存之间的概要关系。

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223219_276.jpg '03.png')](http://www.importnew.com/14486.html/03-png)

从硬件上看，Linux 系统的内存空间由两个部分构成：物理内存和 SWAP（位于磁盘）。物理内存是 Linux 活动时使用的主要内存区域；当物理内 存不够使用时，Linux 会把一部分暂时不用的内存数据放到磁盘上的 SWAP 中去，以便腾出更多的可用内存空间；而当需要使用位于 SWAP 的数据时，必须 先将其换回到内存中。

从 Linux 系统上看，除了引导系统的 BIN 区，整个内存空间主要被分成两个部分：内核内存（Kernel space）、用户内存（User space）。  
内核内存是 Linux 自身使用的内存空间，主要提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。用户内存是提供给各个进程主要空间，Linux 给 各个进程提供相同的虚拟内存空间；这使得进程之间相互独立，互不干扰。实现的方法是采用虚拟内存技术：给每一个进程一定虚拟内存空间，而只有当虚拟内存实 际被使用时，才分配物理内存。如下图所示，对于 32 的 Linux 系统来说，一般将 0 ～ 3G 的虚拟内存空间分配做为用户空间，将 3 ～ 4G 的虚拟内存空间分配 为内核空间；64 位系统的划分情况是类似的。

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223220_721.jpg '04')](http://www.importnew.com/14486.html/04-2)

从进程的角度来看，进程能直接访问的用户内存（虚拟内存空间）被划分为 5 个部分：代码区、数据区、堆区、栈区、未使用区。代码区中存放应用程序的机 器代码，运行过程中代码不能被修改，具有只读和固定大小的特点。数据区中存放了应用程序中的全局数据，静态数据和一些常量字符串等，其大小也是固定的。堆 是运行时程序动态申请的空间，属于程序运行时直接申请、释放的内存资源。栈区用来存放函数的传入参数、临时变量，以及返回地址等数据。未使用区是分配新内 存空间的预备区域。

# 二、进程与 JVM 内存模型

JVM 本质就是一个进程，因此其内存模型也有进程的一般特点。但是，JVM 又不是一个普通的进程，其在内存模型上有许多崭新的特点，主要原因有两 个：1.JVM 将许多本来属于操作系统管理范畴的东西，移植到了 JVM 内部，目的在于减少系统调用的次数；2. Java NIO，目的在于减少用于读写 IO 的系统调用的开销。 JVM 进程与普通进程内存模型比较如下图:

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223220_523.jpg '05')](http://www.importnew.com/14486.html/05-2)

需要说明的是，这个模型的并不是 JVM 内存使用的精确模型，更侧重于从操作系统的角度而省略了一些 JVM 的内部细节（尽管也很重要）。下面从用户内存和内核内存两个方面讲解 JVM 进程的内存特点。

## 1.用户内存

上图特别强调了 JVM 进程模型的代码区和数据区指的是 JVM 自身的，而非 Java 程序的。普通进程栈区，在 JVM 一般仅仅用做线程栈。JVM 的堆区和普通进程的差别是最大的，下面具体详细说明：

首先是永久代。永久代本质上是 Java 程序的代码区和数据区。Java 程序中类（class），会被加载到整个区域的不同数据结构中去，包括常量 池、域、方法数据、方法体、构造函数、以及类中的专用方法、实例初始化、接口初始化等。这个区域对于操作系统来说，是堆的一个部分；而对于 Java 程序来 说，这是容纳程序本身及静态资源的空间，使得 JVM 能够解释执行 Java 程序。

其次是新生代和老年代。新生代和老年代才是 Java 程序真正使用的堆空间，主要用于内存对象的存储；但是其管理方式和普通进程有本质的区别。  
普通进程在运行时给内存对象分配空间时，比如 C++执行 new 操作时，会触发一次分配内存空间的系统调用，由操作系统的线程根据对象的大小分配好空间后返 回；同时，程序释放对象时，比如 C++执行 delete 操作时，也会触发一次系统调用，通知操作系统对象所占用的空间已经可以回收。  
JVM 对内存的使用和一般进程不同。JVM 向操作系统申请一整段内存区域（具体大小可以在 JVM 参数调节）作为 Java 程序的堆（分为新生代和老年代）； 当 Java 程序申请内存空间，比如执行 new 操作，JVM 将在这段空间中按所需大小分配给 Java 程序，并且 Java 程序不负责通知 JVM 何时可以释放这 个对象的空间，垃圾对象内存空间的回收由 JVM 进行。

JVM 的内存管理方式的优点是显而易见的，包括：第一，减少系统调用的次数，JVM 在给 Java 程序分配内存空间时不需要操作系统干预，仅仅在 Java 堆大小变化时需要向操作系统申请内存或通知回收，而普通程序每次内存空间的分配回收都需要系统调用参与；第二，减少内存泄漏，普通程序没有（或者 没有及时）通知操作系统内存空间的释放是内存泄漏的重要原因之一，而由 JVM 统一管理，可以避免程序员带来的内存泄漏问题。

最后是未使用区，未使用区是分配新内存空间的预备区域。对于普通进程来说，这个区域被可用于堆和栈空间的申请及释放，每次堆内存分配都会使用这个区 域，因此大小变动频繁；对于 JVM 进程来说，调整堆大小及线程栈时会使用该区域，而堆大小一般较少调整，因此大小相对稳定。操作系统会动态调整这个区域的 大小，并且这个区域通常并没有被分配实际的物理内存，只是允许进程在这个区域申请堆或栈空间。

## 2.内核内存

应用程序通常不直接和内核内存打交道，内核内存由操作系统进行管理和使用；不过随着 Linux 对性能的关注及改进，一些新的特性使得应用程序可以使 用内核内存，或者是映射到内核空间。Java NIO 正是在这种背景下诞生的，其充分利用了 Linux 系统的新特性，提升了 Java 程序的 IO 性能。

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223220_372.jpg '06')](http://www.importnew.com/14486.html/06-2)

上图给出了 Java NIO 使用的内核内存在 linux 系统中的分布情况。nio buffer 主要包括：nio 使用各种 channel 时所使用的 ByteBuffer、Java 程序主动使用 ByteBuffer.allocateDirector 申请分配的 Buffer。而在 PageCache 里面，nio 使用的内存主要包 括：FileChannel.map 方式打开文件占用 mapped、FileChannel.transferTo 和 FileChannel.transferFrom 所需要的 Cache（图中标示 nio file）。

通过 JMX 可以监控到 NIO Buffer 和 mapped 的使用情况，如下图所示。不过，FileChannel 的实现是通过系统调用使用原生的 PageCache，过程对于 Java 是透明的，无法监控到这部分内存的使用大小。

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223221_727.jpg '07')](http://www.importnew.com/14486.html/07-2)

Linux 和 Java NIO 在内核内存上开辟空间给程序使用，主要是减少不要的复制，以减少 IO 操作系统调用的开销。例如，将磁盘文件的数据发送网卡，使用普通方法和 NIO 时，数据流动比较下图所示：

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223221_225.jpg '08')](http://www.importnew.com/14486.html/08-2)

将数据在内核内存和用户内存之间拷贝是比较消耗资源和时间的事情，而从上图我们可以看到，通过 NIO 的方式减少了 2 次内核内存和用户内存之间的数据拷贝。这是 Java NIO 高性能的重要机制之一（另一个是异步非阻塞）。

从上面可以看出，内核内存对于 Java 程序性能也非常重要，因此，在划分系统内存使用时候，一定要给内核留出一定可用空间。

# 三、案例分析

## 1.内存分配问题

通过上面的分析，省略比较小的区域，可以总结 JVM 占用的内存：  
JVM 内存 ≈ Java 永久代 ＋ Java 堆(新生代和老年代) ＋ 线程栈＋ Java NIO

回到文章开头提出的问题，原来的内存分配是：6g(java 堆) ＋ 600m(监控) ＋ 800m(系统)，剩余大约 600m 内存未分配。

现在分析这 600m 内存的分配情况：  
(1)Linux 保留大约 200m，这部分是 Linux 正常运行的需要，  
(2)Java 服务的线程数量是 160 个，JVM 默认的线程栈大小是 1m，因此使用 160m 内存，  
(3)Java NIO buffer，通过 JMX 查到最多占用了 200m，  
(4)Java 服务使用 NIO 大量读写文件，需要使用 PageCache，正如前面分析，这个暂时不好定量估算大小。  
前三项加起来已经 560m，因此可以断定 Linux 物理内存不够使用。

细心的人会发现，引言中给出两个服务器，一个 SWAP 最多占用了 2.16g，另外一个 SWAP 最多占用了 871m；但是，似乎我们的内存缺口没有那么大。事实上，这是由于 SWAP 和 GC 同时进行造成的，从下图可以看到，SWAP 的使用和长时间的 GC 在同一时刻发生。

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223221_472.jpg '09')](http://www.importnew.com/14486.html/09-2)

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223222_22.jpg '10')](http://www.importnew.com/14486.html/10-7)

SWAP 和 GC 同时发生会导致 GC 时间很长，JVM 严重卡顿，极端的情况下会导致服务崩溃。原因如下：JVM 进行 GC 时，时需要对相应堆分区的已用 内存进行遍历；假如 GC 的时候，有堆的一部分内容被交换到 SWAP 中，遍历到这部分的时候就需要将其交换回内存，同时由于内存空间不足，就需要把内存中堆 的另外一部分换到 SWAP 中去；于是在遍历堆分区的过程中，(极端情况下)会把整个堆分区轮流往 SWAP 写一遍。Linux 对 SWAP 的回收是滞后的，我 们就会看到大量 SWAP 占用。

上述问题，可以通过减少堆大小，或者增加物理内存解决。

因此，我们得出一个结论：部署 Java 服务的 Linux 系统，在内存分配上，需要避免 SWAP 的使用；具体如何分配需要综合考虑不同场景下 JVM 对 Java 永久代 、Java 堆(新生代和老年代)、线程栈、Java NIO 所使用内存的需求。

## 2.内存泄漏问题

另一个案例是，8g 内存的服务器，Linux 使用 800m，监控进程使用 600m，堆大小设置 4g；系统可用内存有 2.5g 左右，但是也发生了大量的 SWAP 占用。  
分析这个问题如下：  
(1)在这个场景中， Java 永久代 、Java 堆(新生代和老年代)、线程栈所用内存基本是固定的，因此，占用内存过多的原因就定位在 Java NIO 上。  
(2)根据前面的模型，Java NIO 使用的内存主要分布在 Linux 内核内存的 System 区和 PageCache 区。查看监控的记录，如下图，我们可以看到发生 SWAP 之前，也就是 物理内存不够使用的时候，PageCache 急剧缩小。因此，可以定位在 System 区的 Java NIO Buffer 发生内存泄漏。

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223222_263.jpg '11')](http://www.importnew.com/14486.html/11-9)

[![ Linux与JVM的内存关系分析](http://static.open-open.com/lib/uploadImg/20150109/20150109223223_157.jpg '12')](http://www.importnew.com/14486.html/12-8)

(3)由于 NIO 的 DirectByteBuffer 需要在 GC 的后期被回收，因此连续申请 DirectByteBuffer 的程序，通常需要调用 System.gc()，避免长时间不发生 FullGC 导致引用在 old 区的 DirectByteBuffer 内存泄漏。分析到此，可以推断有两种可能的 原因：第一，Java 程序没有在必要的时候调用 System.gc()；第二，System.gc()被禁用。  
(4)最后是要排查 JVM 启动参数和 Java 程序的 DirectByteBuffer 使用情况。在本例中，查看 JVM 启动参数，发现启用了-XX:+DisableExplicitGC 导致 System.gc()被禁用。

# 四、总结

本文详细分析了 Linux 与 JVM 的内存关系，比较了一般进程与 JVM 进程使用内存的异同点，理解这些特性将对 Linux 系统内存分配、JVM 调优、Java 程序优化有帮助。限于篇幅关系仅仅列举两个案例，希望起到抛砖引玉的作用。
